<!DOCTYPE html>
<html lang="uk">

<head id="head">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' style='background:black'><text y='16' font-family='Trebuchet MS' font-weight='900' fill='orange'>UB</text></svg>">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/dark.css">

  <title>5 рівнів мислення в програмуванні - дослідження Gemini</title>
</head>

<body id="body">
  <main>
    <h1>Обґрунтований погляд на п'ять рівнів мислення для JavaScript-програмістів</h1>
    <p>Програмування, особливо в динамічному ландшафті вебу та JavaScript, виходить за рамки простого написання коду. Воно вимагає добре визначеної організаційної структури для проєктів, управління даними та систем взаємодії. Щоб складність не переросла в безлад, а проєкти не стали громіздкими, програмістам слід розвивати здатність мислити на п'яти різних, але взаємопов'язаних рівнях. Мета цього звіту — надати більш обґрунтований та деталізований погляд на цю п'ятирівневу модель мислення, з особливим акцентом на тонкощах коду, даних та зв'язувань (bindings) в екосистемі JavaScript.</p>

    <h2>Фундаментальна важливість структурованого мислення в розробці програмного забезпечення</h2>
    <p>Системний підхід до розробки програмного забезпечення є вирішальним для навігації у властивих цій галузі складнощах. Структуроване мислення надає надійну основу, яка дозволяє розробникам розбивати складні проблеми на менші, більш керовані компоненти, сприяючи ясності та ефективності протягом усього життєвого циклу розробки. Цей метод не тільки допомагає зрозуміти обсяг проблеми, але й полегшує пошук ефективних рішень. Застосовуючи структуроване мислення, розробники можуть покращити командну співпрацю, оптимізувати процеси та, зрештою, постачати програмне забезпечення вищої якості. Здатність декомпонувати складні завдання, розпізнавати закономірності в даних та алгоритмах, а також абстрагувати загальні принципи з конкретних випадків — усе це ознаки структурованого мислення, які ведуть до більш ефективного та інноваційного коду. Крім того, цей підхід заохочує допитливий розум та розгляд альтернативних рішень, що потенційно призводить до створення більш надійного програмного забезпечення. Акцент на ретельному плануванні та організації, властивий структурованому мисленню, відображає стратегічне планування, необхідне в інших складних починаннях, гарантуючи, що проєкти будуються на міцному фундаменті. Цей структурований підхід також сприяє кращій комунікації між членами команди та зацікавленими сторонами, оскільки він забезпечує спільну основу для розуміння як проблеми, так і запропонованого рішення.</p>

    <h2>Рівень 1: Папки та файли — Структурування ландшафту проєкту</h2>
    <p>Початковий рівень мислення програміста включає фізичну організацію проєкту. Це охоплює рішення про те, як структурувати папки та файли для забезпечення читабельності та підтримуваності коду. На цьому рівні можуть застосовуватися різні стратегії: від зберігання всього коду в одному файлі до його поділу за мовою (.html, .css, .js), призначенням (відокремлення компонентів) або взаємодією клієнт-сервер (Front/Backend). Також можуть використовуватися більш детальні методології, такі як патерн 7-1. Адекватно організована структура файлів і папок сприяє розподілу відповідальності між різними частинами кодової бази, полегшуючи навігацію та розуміння проєкту. Також важливо зазначити, що організація під час розробки може відрізнятися від структури розгорнутого застосунку, часто оптимізованої збирачами проєктів, такими як Webpack, Parcel або Rollup. Цей рівень закладає основу для того, де знаходиться код, що безпосередньо впливає на наступний рівень — що саме написано.</p>

    <h2>Рівень 2: Код — Сутність інструкцій</h2>
    <p>На рівні коду абстрактні ідеї перетворюються на конкретні команди, що відповідають синтаксису мови програмування. У JavaScript це включає розуміння фундаментальних будівельних блоків коду: токенів, виразів та інструкцій.</p>

    <h3>A. Токени: Лексичні одиниці JavaScript</h3>
    <p>Токени — це найменші окремі одиниці, які розпізнає інтерпретатор JavaScript. Вони формують словниковий запас мови і включають ключові слова, ідентифікатори, оператори, літерали, роздільники та коментарі.</p>

    <ul>
      <li><strong>Ключові слова:</strong> Це зарезервовані слова зі спеціальним значенням у JavaScript, які не можна використовувати як ідентифікатори. Приклади: <code>const</code>, <code>let</code>, <code>var</code> для оголошення змінних; <code>function</code>, <code>class</code> для визначення функцій та класів; <code>if</code>, <code>else</code>, <code>for</code>, <code>while</code> для керування потоком виконання; та <code>import</code>, <code>export</code> для управління модулями.</li>

      <li><strong>Ідентифікатори:</strong> Це імена, що надаються змінним, функціям, класам та об'єктам. Вони повинні починатися з літери, знака підкреслення (<code>_</code>) або знака долара (<code>$</code>) і можуть містити ці символи, а також цифри. JavaScript чутливий до регістру, тому <code>myVar</code> та <code>myvar</code> — різні ідентифікатори.</li>

      <li><strong>Оператори:</strong> Ці символи виконують операції над значеннями даних. JavaScript пропонує широкий спектр операторів, включаючи арифметичні (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>), присвоєння (<code>=</code>, <code>+=</code>, <code>-=</code>), порівняння (<code>==</code>, <code>===</code>, <code>&gt;</code>, <code>&lt;</code>), логічні (<code>&amp;&amp;</code>, <code>||</code>, <code>!</code>) та побітові (<code>&amp;</code>, <code>|</code>, <code>^</code>).</li>

      <li><strong>Літерали:</strong> Це фіксовані значення, які з'являються безпосередньо в коді. Приклади включають рядкові літерали (наприклад, <code>"hello"</code>), числові літерали (наприклад, <code>42</code>, <code>3.14</code>), булеві літерали (<code>true</code>, <code>false</code>), <code>null</code>, <code>undefined</code>, літерали BigInt (наприклад, <code>123n</code>) та літерали регулярних виразів (наприклад, <code>/abc/</code>).</li>

      <li><strong>Роздільники (Punctuators):</strong> Це символи, що використовуються для розділення та групування елементів коду, а також для визначення структури коду. Приклади включають круглі дужки <code>()</code>, фігурні дужки <code>{}</code>, квадратні дужки <code>[]</code>, коми <code>,</code>, крапки з комою <code>;</code> та двокрапки <code>:</code>.</li>

      <li><strong>Коментарі:</strong> Це анотації в коді, які ігноруються інтерпретатором JavaScript, але надають пояснення та контекст для розробників. JavaScript підтримує однорядкові коментарі (з використанням <code>//</code>) та багаторядкові блокові коментарі (з використанням <code>/*... */</code>).</li>
    </ul>

    <h3>B. Вирази: Створення значень</h3>
    <p>Вирази — це допустимі одиниці коду, які обчислюються в значення. Вони можуть бути простими, як один токен, або складними, як комбінація кількох токенів, операторів та вкладених підвиразів.</p>

    <ul>
      <li><strong>Прості вирази:</strong> Складаються з одного токена, який безпосередньо представляє значення або посилається на нього. Приклади: числовий літерал на кшталт <code>10</code>, рядковий літерал на кшталт <code>"hello"</code>, булевий літерал на кшталт <code>true</code>, ідентифікатор, що посилається на змінну (наприклад, <code>x</code>), або ключове слово <code>this</code>.</li>

      <li><strong>Складні вирази:</strong> Формуються шляхом поєднання простих виразів з операторами.
        <ul>
          <li><strong>Арифметичні вирази:</strong> Включають арифметичні оператори, наприклад, <code>a + b * c</code>. Порядок операцій визначається пріоритетом операторів, який можна змінити за допомогою дужок.</li>

          <li><strong>Логічні вирази:</strong> Використовують логічні оператори (<code>&amp;&amp;</code>, <code>||</code>, <code>!</code>) для об'єднання булевих значень або виразів, наприклад, <code>x &amp;&amp; y || !z</code>. Ці вирази часто демонструють скорочене обчислення (short-circuit evaluation).</li>

          <li><strong>Умовні (тернарні) вирази:</strong> Надають короткий спосіб виконання логіки if-else, наприклад, <code>condition ? value1 : value2</code>.</li>

          <li><strong>Вирази виклику функції:</strong> Виконують функцію та повертають її значення, наприклад, <code>myFunction(arg1, arg2)</code>.</li>

          <li><strong>Вирази літералів об'єкта та масиву:</strong> Створюють нові об'єкти та масиви, наприклад, <code>{ key: 'value' }</code> та <code>[1, 2, 3]</code>.</li>
        </ul>
      </li>
    </ul>

    <p>Вирази відіграють вирішальну роль у JavaScript, оскільки вони є основним засобом створення та маніпулювання значеннями даних під час виконання.</p>

    <h3>C. Інструкції (Statements): Вказівки до дії</h3>
    <p>Інструкції — це вказівки, які повідомляють інтерпретатору JavaScript про необхідність виконати дію. Програма JavaScript по суті є послідовністю інструкцій. Інструкції часто містять вирази для виконання своїх завдань.</p>

    <ul>
      <li><strong>Інструкції оголошення:</strong> Вводять змінні (<code>let</code>, <code>const</code>, <code>var</code>), функції (<code>function</code>) та класи (<code>class</code>) в область видимості програми. Вони пов'язують ідентифікатори зі значеннями або визначають блоки коду для повторного використання. Інструкції, пов'язані з модулями, такі як <code>import</code> та <code>export</code>, також належать до цієї категорії, керуючи обміном кодом між різними файлами.</li>

      <li><strong>Інструкції керування потоком:</strong> Керують порядком виконання інструкцій. Інструкції <code>if/else</code> дозволяють умовно виконувати блоки коду, а інструкції <code>switch</code> надають спосіб виконання різного коду залежно від значення виразу. Інструкція <code>return</code> вказує значення, яке має повернути функція, а інструкції <code>break</code> та <code>continue</code> змінюють потік виконання циклів. Інструкція <code>throw</code> використовується для сигналізації про помилки.</li>

      <li><strong>Інструкції циклу:</strong> Повторюють блок коду кілька разів. JavaScript пропонує різні конструкції циклів, такі як <code>for</code>, <code>while</code>, <code>do...while</code>, <code>for...in</code> (для ітерації по властивостях об'єкта), <code>for...of</code> (для ітерації по ітерованих об'єктах) та <code>for await...of</code> (для асинхронних ітерованих об'єктів).</li>

      <li><strong>Обробка винятків:</strong> Інструкція <code>try/catch/finally</code> дозволяє розробникам коректно обробляти помилки часу виконання. Код, який може викликати помилку, розміщується в блоці <code>try</code>, а блок <code>catch</code> вказує, як обробити помилку. Необов'язковий блок <code>finally</code> містить код, який виконується завжди, незалежно від того, чи сталася помилка.</li>

      <li><strong>Інструкції-вирази:</strong> Будь-який допустимий вираз JavaScript також може використовуватися як інструкція. У таких випадках вираз обчислюється, і його результат відкидається, якщо він не має побічних ефектів. Поширені приклади включають виклики функцій, такі як <code>console.log('hello');</code>, присвоєння, такі як <code>x = 5;</code>, та операції інкременту/декременту, такі як <code>i++;</code>. Ці інструкції є фундаментальними для виконання дій у програмі JavaScript.</li>
    </ul>

    <p>Розуміння взаємодії між токенами, виразами та інструкціями є важливим для написання синтаксично коректного та логічно правильного коду JavaScript. Токени формують базовий словниковий запас, вирази створюють значення, а інструкції використовують ці значення для виконання дій, що становлять поведінку програми.</p>

    <h2>Рівень 3: Дані (Значення) та структури даних — Царство інформації</h2>
    <p>Рішення щодо вибору та організації даних мають першочергове значення в розробці програмного забезпечення. JavaScript надає набір примітивних та складних типів даних для представлення та структурування інформації.</p>

    <h3>A. Примітивні типи даних: Одиничні значення</h3>
    <p>JavaScript пропонує сім примітивних типів даних, кожен з яких представляє єдине, незмінне значення.</p>

    <ul>
      <li><strong>Boolean:</strong> Представляє логічну сутність і може мати два значення: <code>true</code> або <code>false</code>.</li>

      <li><strong>Number:</strong> Представляє числові значення, включаючи як цілі числа, так і числа з плаваючою комою. У JavaScript є лише один тип Number.</li>

      <li><strong>String:</strong> Представляє послідовність символів, укладену в одинарні (<code>'</code>) або подвійні (<code>"</code>) лапки.</li>

      <li><strong>Undefined:</strong> Представляє змінну, яка була оголошена, але їй ще не було присвоєно значення. Це також значення, що повертається функцією, яка явно нічого не повертає.</li>

      <li><strong>Null:</strong> Представляє навмисну відсутність значення. Це примітивне значення, яке представляє нульове, порожнє або неіснуюче посилання.</li>

      <li><strong>BigInt:</strong> Представляє цілі числа довільної довжини, дозволяючи виконувати операції над числами, що перевищують безпечний ліміт цілих чисел типу Number. Літерали BigInt створюються додаванням <code>n</code> в кінець цілого числа.</li>

      <li><strong>Symbol:</strong> Представляє унікальне та незмінне примітивне значення. Символи часто використовуються як ключі для властивостей об'єктів, щоб уникнути конфліктів імен.</li>
    </ul>

    <h3>B. Складний тип даних: Об'єкти — Колекції інформації</h3>
    <p>Об'єкти — єдиний складний тип даних у JavaScript. Вони є колекціями пар ключ-значення, де ключі зазвичай є рядками (або символами), а значення можуть бути будь-яким типом даних JavaScript, включаючи інші об'єкти. Об'єкти дозволяють представляти більш складні сутності та відносини.</p>

    <h3>C. Вбудовані типи об'єктів: Спеціалізовані структури</h3>
    <p>Крім базового типу об'єкта, середовища JavaScript (браузери та Node.js) надають великий набір вбудованих типів об'єктів, кожен з яких призначений для певних цілей. Ці об'єкти часто мають заздалегідь визначену структуру з конкретними властивостями та методами, ефективно "типізуючи" дані, які вони містять, на більш глибокому рівні. Хоча загальна кількість цих типів об'єктів велика (наближається до тисячі в сучасних середовищах), відносно невеликий піднабір є необхідним для більшості програмістів JavaScript. Знайомства приблизно з 15-30 з цих типів часто достатньо для широкого кола завдань.</p>
    <p>Поширені та важливі вбудовані типи об'єктів включають:</p>

    <table>
      <tbody>
        <tr>
          <td><strong>Тип об'єкта</strong></td>
          <td><strong>Функція-конструктор</strong></td>
          <td><strong>Основне призначення</strong></td>
        </tr>
        <tr>
          <td>Array (Масив)</td>
          <td><code>Array</code></td>
          <td>Впорядкована колекція значень, доступних за індексом</td>
        </tr>
        <tr>
          <td>Set (Множина)</td>
          <td><code>Set</code></td>
          <td>Колекція унікальних значень</td>
        </tr>
        <tr>
          <td>Map (Карта)</td>
          <td><code>Map</code></td>
          <td>Колекція пар ключ-значення, де ключі можуть бути будь-якого типу</td>
        </tr>
        <tr>
          <td>Function (Функція)</td>
          <td><code>Function</code></td>
          <td>Викликаний об'єкт, що представляє блок коду для повторного використання</td>
        </tr>
        <tr>
          <td>Date (Дата)</td>
          <td><code>Date</code></td>
          <td>Представляє певний момент часу</td>
        </tr>
        <tr>
          <td>Error (Помилка)</td>
          <td><code>Error</code></td>
          <td>Базовий об'єкт для екземплярів помилок; існують підтипи, такі як <code>TypeError</code>, <code>RangeError</code></td>
        </tr>
        <tr>
          <td>Event (Подія)</td>
          <td><code>Event</code></td>
          <td>Представляє подію в браузері або середовищі виконання</td>
        </tr>
        <tr>
          <td>EventTarget (Ціль події)</td>
          <td><code>EventTarget</code></td>
          <td>Інтерфейс, реалізований об'єктами, які можуть отримувати та обробляти події</td>
        </tr>
        <tr>
          <td>HTMLElement (HTML-елемент)</td>
          <td>Різні (напр., <code>HTMLDivElement</code>)</td>
          <td>Представляє HTML-елемент в Об'єктній Моделі Документа (DOM)</td>
        </tr>
        <tr>
          <td>HTMLCollection (Колекція HTML)</td>
          <td>Залежить від браузера</td>
          <td>Представляє колекцію HTML-елементів</td>
        </tr>
        <tr>
          <td>Node (Вузол)</td>
          <td>Різні (напр., <code>Element</code>, <code>Text</code>)</td>
          <td>Представляє вузол у дереві DOM</td>
        </tr>
        <tr>
          <td>NodeList (Список вузлів)</td>
          <td>Залежить від браузера</td>
          <td>Представляє колекцію вузлів DOM</td>
        </tr>
        <tr>
          <td>Promise (Обіцянка)</td>
          <td><code>Promise</code></td>
          <td>Представляє кінцевий результат асинхронної операції</td>
        </tr>
        <tr>
          <td>Buffer (Буфер)</td>
          <td><code>Buffer</code></td>
          <td>Представляє необроблені двійкові дані (переважно в Node.js)</td>
        </tr>
        <tr>
          <td>ReadableStream (Читабельний потік)</td>
          <td><code>ReadableStream</code></td>
          <td>Представляє потік даних, з якого можна читати</td>
        </tr>
        <tr>
          <td>WritableStream (Записуваний потік)</td>
          <td><code>WritableStream</code></td>
          <td>Представляє потік даних, в який можна записувати</td>
        </tr>
      </tbody>
    </table>

    <p>Ці вбудовані типи об'єктів надають потужні абстракції для вирішення загальних завдань програмування, від управління колекціями даних до взаємодії з середовищем браузера або обробки асинхронних операцій.</p>

    <h3>D. Дані та код: Необхідне розрізнення</h3>
    <p>У контексті цієї моделі мислення важливо усвідомлювати, що код і дані є різними сутностями. Строго кажучи, сам код не містить даних у сенсі значень часу виконання. На Рівні 2 (Код) ми зустрічаємо вирази — це інструкції, які при обчисленні рушієм JavaScript під час виконання можуть створювати дані. Приклади таких виразів, що продукують дані:</p>

    <ul>
      <li><strong>Літерали:</strong> Безпосередньо представляють значення даних у коді. Наприклад, літерал <code>42</code> — це число, яке буде значенням даних під час виконання програми.</li>

      <li><strong>Ідентифікатори:</strong> Хоча ідентифікатор з'являється в коді, він сам по собі не зберігає дані. Натомість він посилається на зв'язування (обговорюється на Рівні 4), яке зберігає значення даних у пам'яті. Коли ідентифікатор є частиною виразу, рушій JavaScript отримує дані, пов'язані з його зв'язуванням.</li>

      <li><strong>Виклики функцій:</strong> Коли функція викликається у виразі, виконується код функції, і вона часто повертає значення даних як результат. Це повернуте значення потім стає частиною обчислення більшого виразу.</li>
    </ul>

    <p>Таким чином, на рівні коду ми по суті визначаємо, як дані будуть створюватися та оброблятися за допомогою виразів. Фактичні дані, як конкретні значення, з'являються, коли ці вирази обчислюються під час виконання програми.</p>

    <h3>E. Непостійність незв'язаних даних</h3>
    <p>Ключовим аспектом управління даними в JavaScript є концепція зв'язувань. Дані, створені під час виконання коду, якщо вони не пов'язані з якоюсь формою зв'язуючої сутності, зазвичай є короткоживучими. Середовище виконання JavaScript використовує механізм, що називається збиранням сміття, для автоматичного керування пам'яттю. Коли на фрагмент даних у пам'яті більше не посилається жодне активне зв'язування (наприклад, змінна або властивість), збирач сміття ідентифікує його як непотрібний і звільняє займану ним пам'ять. Цей процес гарантує, що застосунок з часом не вичерпає пам'ять. Отже, якщо дані створюються в результаті обчислення виразу, але згодом не прив'язуються до зв'язування, вони незабаром будуть видалені з пам'яті збирачем сміття. Це підкреслює важливу роль зв'язувань у збереженні даних, до яких потрібно звертатися та використовувати їх поза межами безпосереднього обчислення виразу, що їх створив.</p>

    <h2>Рівень 4: Зв'язуючі сутності (Binding Entities) — З'єднання коду з даними</h2>
    <p>Зв'язування є фундаментальними для того, як JavaScript керує даними. Вони слугують зв'язками або посиланнями, які з'єднують ідентифікатори в коді з фактичними значеннями даних, що знаходяться в пам'яті, гарантуючи, що дані зберігаються і ними можна маніпулювати за потребою.</p>

    <h3>A. Ідентифікатори як представлення зв'язувань</h3>
    <p>З точки зору самого коду (Рівень 2), ми не взаємодіємо безпосередньо зі зв'язуючими сутностями. Натомість ми використовуємо їхні відповідні ідентифікатори. Ідентифікатор діє як символічне ім'я, яке рушій JavaScript розпізнає як конкретну зв'язуючу сутність у пам'яті. Коли ми використовуємо ідентифікатор у виразі, ми по суті інструктуємо рушій отримати доступ або маніпулювати даними, пов'язаними зі зв'язуванням, яке представляє ідентифікатор.</p>

    <h3>B. Категорії зв'язуючих сутностей</h3>
    <p>JavaScript надає кілька способів створення зв'язувань, кожен з яких має дещо відмінні характеристики та область видимості. Зазвичай розрізняють сім видів зв'язуючих сутностей:</p>

    <ul>
      <li><strong>Змінні (Variables):</strong> Оголошуються за допомогою <code>let</code> або <code>var</code>, змінні — це іменовані посилання на дані, які можна перепризначити (у випадку <code>let</code> та <code>var</code>).</li>

      <li><strong>Константи (Constants):</strong> Оголошуються за допомогою <code>const</code>, константи також є іменованими посиланнями на дані, але їхнє значення не можна перепризначити після ініціалізації.</li>

      <li><strong>Функції (Functions):</strong> Оголошуються за допомогою <code>function</code> або як стрілкові функції, функції — це зв'язування, які містять блок коду, який можна виконати. Функції також можуть розглядатися як дані (функції першого класу).</li>

      <li><strong>Параметри (Parameters):</strong> Це іменовані посилання на значення (аргументи), передані функції під час її виклику. Параметри поводяться як локальні змінні в області видимості функції.</li>

      <li><strong>Властивості (Properties):</strong> Це іменовані посилання на дані, що належать об'єкту. Властивості унікально ідентифікуються всередині об'єкта за їхніми ключами.</li>

      <li><strong>Методи (Methods):</strong> Це функції, пов'язані з об'єктом і доступні через його властивості. По суті, метод — це властивість, значенням якої є функція.</li>

      <li><strong>Класи (Classes):</strong> Оголошуються за допомогою ключового слова <code>class</code>, класи по суті є особливим видом функцій, які слугують кресленнями для створення об'єктів (екземплярів).</li>
    </ul>

    <p>Важливо зазначити, що ці категорії не завжди є взаємовиключними; вони часто перетинаються. Наприклад, параметри є типом змінної в контексті функції, а методи — це властивості, що містять значення функцій. Самі класи є формою функції в JavaScript. Розуміння цих перетинів допомагає зрозуміти базові механізми та те, як ці різні зв'язуючі сутності співвідносяться одна з одною.</p>

    <h3>C. Роль зв'язувань у життєвому циклі даних</h3>
    <p>Зв'язування є необхідними для забезпечення довговічності даних, створених під час виконання програми. Коли дані створюються (наприклад, новий об'єкт, рядок, отриманий в результаті операції), вони знаходяться в пам'яті. Якщо на ці дані не посилається жодне зв'язування, збирач сміття JavaScript врешті-решт звільнить цю пам'ять. Пов'язуючи дані зі зв'язуванням (наприклад, присвоюючи їх змінній, роблячи їх властивістю об'єкта), ми створюємо посилання, яке запобігає їх негайному видаленню збирачем сміття. Дані залишатимуться в пам'яті доти, доки існує та доступне зв'язування, яке на них посилається. Цей механізм дозволяє програмам підтримувати стан та працювати з даними протягом часу.</p>

    <h3>D. Операції над зв'язуваннями та даними, які вони містять</h3>
    <p>Операції, які можна безпосередньо виконувати над зв'язуючою сутністю, досить обмежені і в основному включають читання значення (або посилання), яке містить зв'язування, та присвоєння йому нового значення (або посилання). Наприклад, коли ми використовуємо ідентифікатор змінної у виразі, ми по суті читаємо дані, з якими пов'язана змінна. Аналогічно, коли ми використовуємо оператор присвоєння (<code>=</code>) зі змінною, ми змінюємо дані, з якими пов'язана змінна (або змушуємо її посилатися на інший фрагмент даних).</p>
    <p>На відміну від цього, більшість операцій, які ми, здавалося б, виконуємо над зв'язуваннями через їхні ідентифікатори в коді, насправді виконуються над даними, на які ці зв'язування посилаються. Розглянемо вираз <code>x + 5</code>, де <code>x</code> — змінна, пов'язана з числом. Операція додавання виконується не над самим зв'язуванням <code>x</code>, а над числовим значенням, що зберігається в комірці пам'яті, на яку посилається <code>x</code>. Рушій JavaScript спочатку розпізнає ідентифікатор <code>x</code> як відповідне зв'язування, отримує дані, пов'язані з цим зв'язуванням, а потім виконує додавання. Це розрізнення є надзвичайно важливим для розуміння того, що зв'язування — це, по суті, механізми доступу та управління даними, тоді як фактична маніпуляція даними відбувається на нижчому рівні, хоча ми використовуємо ідентифікатори зв'язувань у нашому коді.</p>

    <h2>Рівень 5: Інтерфейси — З'єднання із зовнішнім світом</h2>
    <p>Фінальний рівень мислення включає інтерфейси, через які застосунок взаємодіє з користувачами та іншими системами.</p>

    <ul>
      <li><strong>Графічний інтерфейс користувача (GUI):</strong> Охоплює всі візуальні елементи, які дозволяють користувачам переглядати інформацію та взаємодіяти із застосунком, такі як форми, поля введення, кнопки та посилання. Проектування ефективних GUI вимагає глибокого розуміння принципів доступності та користувацького досвіду (UX) для забезпечення простоти використання та інклюзивності.</li>

      <li><strong>Інтерфейс командного рядка (CLI):</strong> Цей текстовий інтерфейс дозволяє користувачам взаємодіяти із застосунком шляхом введення команд. Хоча CLI не такий візуально інтуїтивний, як GUI, він пропонує переваги з точки зору автоматизації та написання скриптів.</li>

      <li><strong>Програмний інтерфейс застосунку (API):</strong> Цей програмний інтерфейс визначає, як різні компоненти програмного забезпечення та застосунки можуть обмінюватися даними та взаємодіяти скоординованим чином. API необхідні для створення складних систем з широкими можливостями, дозволяючи різним частинам безперешкодно працювати разом.</li>
    </ul>

    <p>Програмісти повинні ретельно враховувати цільову аудиторію та передбачувані сценарії використання при виборі та реалізації оптимальних інтерфейсів для своїх застосунків. Кожен тип інтерфейсу має свої сильні та слабкі сторони, і вибір повинен відповідати загальним цілям проєкту.</p>

    <h2>Висновок</h2>
    <p>Ця п'ятирівнева модель мислення надає структурований підхід для JavaScript-програмістів до управління складнощами розробки програмного забезпечення. Свідомо розглядаючи організацію папок і файлів, нюанси синтаксису та семантики коду, вибір та структурування даних, вирішальну роль зв'язувань в управлінні даними та різні інтерфейси для взаємодії, розробники можуть створювати більш ефективні, надійні та підтримувані програмні рішення. Краса добре спроєктованого проєкту полягає в продуманості та очевидній доцільності кожного з його компонентів — якість, яка значно покращується завдяки прийняттю цього комплексного, багаторівневого підходу до програмування.</p>
  </main>
</body>

</html>
